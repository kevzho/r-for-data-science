---
title: "3-data-transformation"
output: html_document
---

### Importing Libraries
```{r}
library(nycflights13)
library(tidyverse)
library(dplyr)

#flights is a tibble, a special type of dataframe used by tidyverse to avoid some common gotchas. 
flights
```

can use `View(flights)`, `print(flights, width = Inf)`, or `glimpse()` to look at the tabular data

```{r}
glimpse(flights)
```
### dplyr basics
1. First argument is always a dataframe.
2. Subsequent arguments describe **which** columns to operate on using variable names (without quotes).
3. Output is always a new dataFrame. 

```{r}
flights |> #the "pipe" is |>, which takes the thing on its left and passes it along to the function on its right.
  filter(dest == "IAH") |>
  group_by(year, month, day) |>
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE) #remove missing values
  )
```

### dplyr verbs (rows)

##### 1. `filter(*condition*)` allows you to keep/filter rows based on values of the columns. For example, you could do this:
```{r eval = FALSE}
flights |>
  filter(dep_delay > 120) #think of it as a "WHERE" clause in SQL, where you are able to input a condition

jan_feb <- flights |> #save result in variable to save the dataframe
  filter(month %in% c(1, 2)) #you can use %in% clause when combining "|" and "==". Keeps rows where variable equals one of the values in the vector describes. 
```

##### 2. `arrange()` changes order of rows based off of the value of the columns. Within the parameter section, you can also specify `arrange(desc())` to order in a descending order. 
```{r eval = FALSE}
flights |> #sorts by year, month, day, then departure time
  arrange(year, month, day, dep_time)
```

##### 3. `distinct()` finds all unique rows in a dataset. Similar to the "DISTINCT" clause in SQL.
```{r eval = FALSE}
flights |>
  distinct(origin, dest, .keep_all = TRUE) #specifies which rows to find unique.
#.keep_all preserves the other columns (without it, the dataframe would just be the 2 columns specified)
```

#### Exercises: 

```{r eval = FALSE}
#1.1
one_one <- flights |>
  filter(arr_delay >= 2)

#1.2
one_two <- flights |>
  filter(dest == "IAH" | dest == "HOU")

#1.3
one_three <- flights |> 
  filter(carrier %in% c("UA", "AA", "DL"))

#1.4
one_four <- flights |>
  filter(month %in% c(6, 7, 8))

#1.5
one_five <- flights |>
  filter(arr_delay > 2 & dep_delay == 0)

#1.6
one_six <- flights |>
  filter(dep_delay >= 1 & (sched_arr_time - sched_dep_time) - air_time > 30)

print("one")
head(one_one, n = 5)
print("two")
head(one_two, n = 5)
print("three")
head(one_three, n = 5)
print("four")
head(one_four, n = 5)
print("five")
head(one_five, n = 5)
print("six")
head(one_six, n = 5)

```
___
### dplyr verbs (columns)

##### 1. `mutate()`: Adds new columns that are calculated from existing columns.
```{r eval = FALSE}
flights |>
  mutate(
    gain = dep_delay - arr_delay, #calculating gain and adding as column
    speed = distance / air_time * 60 #calculating speed and adding as column
    #.before = 1 #-> Optional if you want to add objects to left hand side, if not it will automatically add columns to the right hand side. 
    #.after = day #-> can use a variable name as your position (here, adding columns after the "day" column)
    #.keep = "used" #-> only keep columns that were involved or created in the mutate() step
  )
```
##### 2. `select()`: Allows one to zoom in on a useful subset by only selecting specific columns.
```{r eval = FALSE}
flights |>
  select(year, month, day)
  #select(year:day) -> selects all columns between year and day, inclusive
  #select(!year: day) -> Selects all columns except those from year to day (inclusive)
  #select(where(is.character)) -> selects all columns that are characters
```

Other helper functions that can be used within `select()` include:

- `starts_with("char")`: matches names that begin with "char"

- `ends_with("char")`: same logic as `starts_with()`, searches for names that end with "char"

- `contains("char")`: selects columns that contain "char" within the name

- `num_range("x", 1:3)`: matches `x1`, `x2`, and `x3`


##### 3. `rename()`: renames existing variables
```{r eval = FALSE}
flights |> 
  rename(tail_num = tailnum)
```

4. `relocate()`
```{r eval = FALSE}
flights |> 
  relocate(time_hour, air_time) #defaulted to move variables to front
  #relocate(year:dep_time, .after = time_hour) -> can specify where to put them with .before and .after arguments, similar to mutate()
  #relocate(starts_with("arr), .before = dep_time)
```

#### Exercises: 

```{r eval = FALSE}
#1. 
#sched_dep_time - dep_time = dep_day

#2. 
flights |>
  select(dep_time, dep_delay, arr_time, arr_delay)

#3. Multiple items would appear or there would be an error.
#4. any_of() selects variables contained in character vector. Doesn't check for missing vars, so 
#won't throw error if some variables don't exist. 
#5. 
#6.
flights |>
  rename(air_time_min = air_time) |>
  relocate(air_time_min)
#7.
```
___
### The Pipe
By using "the pipe", which is "|>", it can make code easier to read, as we will not need to nest each function in the previous one.

___

### Groups

##### 1. `group_by()`: Divides dataset into groups, following operations will now work by whatever you're grouped by. 
##### 2. `summarize()`: Reduces dataframe to have a single row for each group.

The two functions above in action:

```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), #ignores all missing values
    n = n() #returns number of rows for each group
  )

```

You can also group by multiple variables:
```{r}
daily <- flights |>
  group_by(year, month, day) #groups by date

daily
```

Summarizing a tibble grouped by more than one variable has each summary peeling of the last group. 

##### 3. The slice functions:
- `df |> slice_head(n = 1)` takes the first row from each group.
- `df |> slice_tail(n = 1)` takes the last row from each group.
- `df |> slice_min(x, n = 1)` Takes the row with the smallest value of column `x`
- `df |> slice_max(x, n = 1)` Takes the row with the largest value of column `x`
- `df |> slice_sample(n = 1)` Takes one random row. 

##### 4. `ungroup()`: Removes grouping data. 
```{r}
daily |> 
  ungroup() |>
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
    #.by = month
    #.by = c(origin, dest) -> The .by argument can also group variables. 
  )
```

#### Exercises: 

```{r eval = FALSE}

```